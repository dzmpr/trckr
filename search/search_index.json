{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>trckr is a Kotlin Symbol Processor (KSP) library designed to enable concise event tracking to multiple analytics platforms.</p> <p>In a large project you can have multiple analytics targets that should receive events from your app. That creates a lot of boilerplate code to implement tracker that uses all analytics targets. Trckr created to eliminate this problem. You need to create target adapters just once, and trckr generate events from interface methods for you. To declare tracker you define interface, annotated with <code>@Tracker</code> annotation and event methods with <code>@Event</code> annotation:</p> Kotlin<pre><code>@Tracker\ninterface ExampleTracker {\n\n    @Event(name = \"Event name\")\n    fun event(\n        @Param(name = \"Parameter name\") data: Int,\n    )\n}\n</code></pre> <p>And create instance of tracker using generated method:</p> Kotlin<pre><code>val tracker = createExampleTracker {  \n    addAdapter(FirebaseAdapter())\n    addAdapter(AmplitudeAdapter())\n    addAdapter(AdjustAdapter())\n}\ntracker.event(data = 42)\n</code></pre> <p>After calling event method trckr sends it to all registered adapters:</p> <pre><code>flowchart TD;\n    E[ExampleTracker] --event--&gt; A;\n    A[Trckr] --event--&gt; B[Firebase] &amp; C[Amplitude] &amp; D[Adjust];</code></pre> <p>To exclude event from being sent to one of the trackers you should specify this adapter class in <code>@Event</code> annotation:</p> Kotlin<pre><code>@Tracker\ninterface ExampleTracker {\n\n    @Event(\n        name = \"Event name\",\n        skipAdapters = [FirebaseAdapter::class],\n    )\n    fun event(\n        @Param(name = \"Parameter name\") data: Int,\n    )\n}\n</code></pre> <p>This code results in <code>FirebaseAdapter</code> will be skipped when <code>event</code> method would be called:</p> <pre><code>flowchart TD;\n    E[ExampleTracker] --event--&gt; A;\n    A[Trckr] ~~~ B[Firebase];\n    A --event--&gt; C[Amplitude] &amp; D[Adjust];</code></pre>"},{"location":"#r8-proguard","title":"R8 / Proguard","text":"<p>Trckr is fully compatible with R8 out of the box and doesn't require adding any extra rules.</p>"},{"location":"#license","title":"License","text":"Text Only<pre><code>Copyright 2022 Dzmitry Pryskoka\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre>"},{"location":"advanced_features/","title":"Advanced features","text":""},{"location":"advanced_features/#skip-adapters","title":"Skip adapters","text":"<p>It's not always needed to send event to all registered adapters. To use such methods in common tracker interface you can specify adapters that will be skipped in <code>@Event</code> annotation.</p> Kotlin<pre><code>@Tracker\ninterface ExampleTracker {\n\n    @Event(skipAdapters = [FirebaseAdapter::class])\n    fun pay(@Param(\"amount\") amount: Double)\n}\n</code></pre> <pre><code>flowchart TD;\n    E[ExampleTracker] --pay--&gt; A;\n    A[Trckr] --&gt; B[Firebase];\n    A --pay--&gt; C[Amplitude] &amp; D[Adjust];</code></pre>"},{"location":"advanced_features/#nullable-parameter-handling","title":"Nullable parameter handling","text":""},{"location":"advanced_features/#skip-null-parameters","title":"Skip null parameters","text":"<p>Nullable parameters with help of default converter would be converted to string \"null\". But if you want to skip such parameter you can set track strategy to <code>TrackStrategy.SKIP_IF_NULL</code>, and it will be sent only if value is not null.</p> Kotlin<pre><code>@Tracker\ninterface ExampleTracker {\n\n    @Event\n    fun userSearch(\n        @Param(\n            name = \"query\",\n            strategy = TrackStrategy.SKIP_IF_NULL,\n        )\n        query: String? = null,\n    )\n}\n</code></pre>"},{"location":"advanced_features/#track-null-parameters","title":"Track null parameters","text":"<p>Parameter converter or type converter should convert value to any not null type. If you need to track null explicitly you can set track strategy to <code>TrackStrategy.TRACK_NULL</code>. Kotlin<pre><code>@Tracker\ninterface ExampleTracker {\n\n    @Event\n    fun userSearch(\n        @Param(\n            name = \"query\",\n            strategy = TrackStrategy.TRACK_NULL,\n        )\n        query: String? = null,\n    )\n}\n</code></pre></p>"},{"location":"advanced_features/#default-behavior","title":"Default behavior","text":"<p>By default, any parameter tries to be converted using type or parameter converters. If none of converters can convert this value (return not null) <code>TrckrConversionException</code> exception will be thrown. </p>"},{"location":"advanced_features/#converters","title":"Converters","text":"<p>To clean up call place you can register converter that would convert parameter value to desired format.</p>"},{"location":"advanced_features/#type-converters","title":"Type converters","text":"<p>Type converter can convert parameter value based only on the value itself. It's suitable when you need to convert all values of certain type. Kotlin<pre><code>class EnumConverter : TypeConverter {\n\n    fun convert(value: Any?): Any? {\n        return if (value is Enum&lt;*&gt;) {\n            value.name\n        } else {\n            null\n        }\n    }\n}\n\nval tracker = createExampleTracker {\n    // ...\n    addConverter(EnumConverter())\n}\n</code></pre></p>"},{"location":"advanced_features/#parameter-converters","title":"Parameter converters","text":"<p>Parameter converter can convert parameter value based on event name, parameter name and passed value. It's allows to convert specific values, even if they are typed with type that converts to another representation by type converter, because trckr check parameter converters before type converters. Kotlin<pre><code>@Tracker\ninterface ExampleTracker {\n\n    @Event\n    fun event(\n        @Param(\"first\") first: Int,\n        @Param(\"second\") second: Int,\n    )\n}\n\nclass FirstParameterConverter : ParameterConverter {\n\n    fun convert(eventName: String, parameterName: String, value: Any?): Any? {\n        return if (event == \"event\" &amp;&amp; parameterName == \"first\") {\n            val isPositive = (value as Int) &gt; 0\n            if (isPositive) \"Positive\" else \"Negative\"\n        } else {\n            null\n        }\n    }\n}\n\nval tracker = createExampleTracker {\n    // ...\n    addConverter(FirstConverter())\n}\ntracker.event(first = -10, second = 20)\n</code></pre></p> <p>Note</p> <p>Parameters converter is a more powerful solution that let you manipulate event parameters, but you need to be careful because this type of converter applies to all parameters of all events in tracker.</p>"},{"location":"advanced_features/#multi-module-support","title":"Multi module support","text":"<p>Trckr supports multimodule projects. You can define module-scoped trackers inside each module like this:</p> Kotlin<pre><code>// Module alpha\ninterface ModuleAlphaTracker {\n\n    @Event\n    fun alphaEvent()\n}\n\n// Module beta\ninterface ModuleBetaTracker {\n\n    @Event\n    fun betaEvent()\n}\n</code></pre> <p>And then, in application module you tie all trackers together: Kotlin<pre><code>@Tracker\ninterface ApplicationTracker : ModuleAlphaTracker, ModuleBetaTracker\n</code></pre> trckr generate <code>ApplicationTracker</code> implementation for you, with all events from inherited tracker interfaces. So you can create tracker and inject it with your DI framework to modules (or pass it manually).</p>"},{"location":"migrate_to_trckr/","title":"Migrate to trckr","text":"<p>When migrating to trckr you need to get familiar with its terminology.</p> <p>Entry point of trckr is a tracker interface where you specify events, its names and parameters.</p> Kotlin<pre><code>@Tracker\ninterface ProductAnalytics {\n\n    @Event(name = \"payment_completed\")\n    fun paymentCompleted(\n        @Param(name = \"amount\") amount: Int,\n    )\n}\n</code></pre> <p>Note</p> <p>If event name was not specified trckr will use event method name as event name. But in case you use minification in your project be careful that event name can change in process of code minification. So I recommend always explicitly specify event name.</p> <p>Based on this interface trckr will generate tracker implementation which you don't have direct access to. You can obtain instance of tracker using <code>create*TrackerName*</code> build (<code>createProductAnalytics</code> in this example). Using this builder you should supply tracker with tracker adapters:</p> Kotlin<pre><code>val tracker = createProductAnalytics {\n    addAdapter(FirstBackendAdapter())\n    addAdapter(SecondBackendAdapter())\n    // and so on ...\n}\n</code></pre> <p>What is tracker adapter? It's a class, responsible for sending events to specific analytics backend. Adapter receive from tracker implementation <code>eventName</code> and map with event <code>parameters</code> (if it's present). Here is sample adapter implementation: Kotlin<pre><code>class FirstBackendAdapter(\n    fbs: FirstBackendService, \n) : TrackerAdapter {\n\n    override fun trackEvent(eventName: String, parameters: Map&lt;String, Any?&gt;) {\n        verifyEventName(eventName)\n        verifyParameters(parameters)\n        fbs.sendEvent(eventName, json.toJson(parameters))\n    }\n}\n</code></pre> In adapter, you could perform backend-specific events' manipulation. For example when sending events to firebase you need to ensure event name consists only from alphanumeric characters and underscores and has no whitespaces. Also, event name should not be longer than 40 characters.</p>"},{"location":"migrate_to_trckr/#migration","title":"Migration","text":"<p>Consider you have simple multi-backend setup:</p> Kotlin<pre><code>// TrackerService.kt\ninterface TrackerService {\n\n    fun firstEvent()\n\n    fun secondEvent(param: Int)\n}\n\n// CompositeTrackerService.kt\nclass CompositeTrackerService(\n    private val trackers: List&lt;TrackerService&gt;,\n) : TrackerService {\n\n    constructor(vararg trackers: TrackerService) : this(trackers.toList())\n\n    override fun firstEvent() {\n        trackers.forEach {\n            it.firstEvent()\n        }\n    }\n\n    override fun secondEvent(param: Int) {\n        trackers.forEach {\n            it.secondEvent(param)\n        }\n    }\n}\n\n// FirstBackendTrackerService.kt\nclass FirstBackendTrackerService : TrackerService {\n\n    override fun firstEvent() { /* first backend tracking logic */\n    }\n\n    override fun secondEvent(param: Int) { /* first backend tracking logic */\n    }\n}\n\n// SecondBackendTrackerService.kt\nclass SecondBackendTrackerService : TrackerService {\n\n    override fun firstEvent() { /* second backend tracking logic */\n    }\n\n    override fun secondEvent(param: Int) { /* second backend tracking logic */\n    }\n}\n</code></pre>"},{"location":"migrate_to_trckr/#migrate-tracker-interface","title":"Migrate tracker interface","text":"<p>At the begging your <code>TrackerService</code> becomes a tracker. You need to add trckr annotations:</p> Kotlin<pre><code>@Tracker\ninterface TrackerService {\n\n    @Event(name = \"firstEvent\")\n    fun firstEvent()\n\n    @Event(name = \"secondEvent\")\n    fun secondEvent(@Param(name = \"param\") param: Int)\n}\n</code></pre>"},{"location":"migrate_to_trckr/#migrate-tracking-logic","title":"Migrate tracking logic","text":"<p>Then you need convert classes, that responsible for tracking events to concrete backends to adapters: Kotlin<pre><code>class FirstBackendTrackerService : TrackerAdapter {\n\n//    override fun firstEvent() { /* first backend tracking logic */ }\n//    \n//    override fun secondEvent(param: Int) { /* first backend tracking logic */ }\n\n    override fun trackEvent(eventName: String, parameters: Map&lt;String, Any&gt;?) {\n        /* common first backend tracking logic */\n    }\n}\n</code></pre></p>"},{"location":"migrate_to_trckr/#migrate-tracker-instantiation","title":"Migrate tracker instantiation","text":"<p>After that you need to update tracker instantiation logic. You no longer need <code>CompositeTrackerService</code> class. In an example I migrate dagger/hilt provides function that instantiate tracker: </p> Kotlin<pre><code>@Provides\nfun provideTrackerService(\n    first: FirstBackendTrackerService,\n    second: SecondBackendTrackerService,\n): TrackerService {\n//    return CompositeTrackerService(first, second)\n    return createTrackerService {\n        add(first)\n        add(second)\n    }\n}\n</code></pre> <p>And now migration is complete!</p>"},{"location":"setup/","title":"Setup","text":"<p>To run trckr you need to add KSP to your project:</p> <p>In module <code>build.gradle.kts</code> you need to apply KSP plugin and specify maven central repository:</p> Kotlin<pre><code>plugins {\n    // ...\n    id(\"com.google.devtools.ksp\") version \"$ksp_version\"\n    // Or if you use gradle version catalog\n    alias(libs.plugins.ksp)\n}\n\nrepositories {\n    // ...\n    mavenCentral()\n}\n</code></pre> <p>KSP is used to generate implementation code from your tracker declarations. Both KSP1 and KSP2 are supported.</p> <p>Then you need to add trckr dependencies:</p>"},{"location":"setup/#single-platform-project","title":"Single platform project","text":"Kotlin<pre><code>dependencies {\n    // ...\n    implementation(\"ru.cookedapp.trckr:trckr-core:$trckr_version\")\n    ksp(\"ru.cookedapp.trckr:trckr-processor:$trckr_version\")\n}\n</code></pre>"},{"location":"setup/#kmp-project","title":"KMP project","text":"<p>Adding trckr to common target allows you to declare tracker interface inside the common code and then create tracker with platform specific adapters in other targets. </p> Kotlin<pre><code>kotlin {\n    sourceSets {\n        androidMain.dependencies {\n            // ..\n            ksp(\"ru.cookedapp.trckr:trckr-processor:$trckr_version\")\n        }\n        commonMain.dependencies {\n            // ...\n            implementation(\"ru.cookedapp.trckr:trckr-core:$trckr_version\")\n        }\n    }\n}\n</code></pre> <p>Then to set your IDE aware of KSP-generated code you need to set up the source path into your module's <code>build.gradle.kts</code> file:</p> Kotlin<pre><code>kotlin {\n// ...\n    sourceSets.configureEach {\n        kotlin.srcDir(layout.buildDirectory.dir(\"/generated/ksp/$name/kotlin/\"))\n    }\n}\n</code></pre>"}]}