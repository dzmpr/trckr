package ru.cookedapp.trckr.processor.generator

import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.google.devtools.ksp.symbol.KSFunctionDeclaration
import com.google.devtools.ksp.symbol.KSType
import com.google.devtools.ksp.symbol.KSVisitorVoid
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.UNIT
import com.squareup.kotlinpoet.ksp.writeTo
import ru.cookedapp.trckr.core.TrckrBuilder
import ru.cookedapp.trckr.core.TrckrCore
import ru.cookedapp.trckr.core.annotations.Event
import ru.cookedapp.trckr.core.annotations.data.TrackStrategy
import ru.cookedapp.trckr.core.event.TrckrEvent
import ru.cookedapp.trckr.core.param.TrckrParam
import ru.cookedapp.trckr.processor.extensions.getAnnotation
import ru.cookedapp.trckr.processor.extensions.getArgumentWithName
import ru.cookedapp.trckr.processor.extensions.packageName
import ru.cookedapp.trckr.processor.extensions.toTypeName
import ru.cookedapp.trckr.processor.helpers.addClass
import ru.cookedapp.trckr.processor.helpers.addFunction
import ru.cookedapp.trckr.processor.helpers.addImport
import ru.cookedapp.trckr.processor.helpers.addPrimaryConstructor
import ru.cookedapp.trckr.processor.helpers.addProperty
import ru.cookedapp.trckr.processor.helpers.createFile
import ru.cookedapp.trckr.processor.helpers.createLambda

internal class TrackerGenerator(private val codeGenerator: CodeGenerator) : KSVisitorVoid() {

    private val eventGenerator = EventGenerator()

    override fun visitClassDeclaration(classDeclaration: KSClassDeclaration, data: Unit) {
        val packageName = classDeclaration.packageName.asString()
        val trackerName = classDeclaration.simpleName.asString()
        val implName = "${trackerName}Impl"
        val trackerType = classDeclaration.toTypeName()

        createFile(packageName, implName) {
            addFileComment("This tracker was generated by trckr symbol processor.\n")
            addFileComment("Do not modify this file.")

            // Imports
            addImport<TrckrEvent>()
            addImport<TrckrParam>()
            addImport<TrackStrategy>()
            addImport(TrckrCore::class.packageName, CREATE_TRCKR_IMPORT)

            // Tracker class
            addClass(implName) {
                addPrimaryConstructor {
                    addParameter(TRCKR_NAME, TrckrCore::class)
                }
                addProperty(TRCKR_NAME, TrckrCore::class) {
                    addModifiers(KModifier.PRIVATE)
                    initializer(TRCKR_NAME)
                }
                addSuperinterface(trackerType)

                classDeclaration.declarations.filterIsInstance<KSFunctionDeclaration>().forEach { method ->
                    addAdapterImports(method)
                    val eventMethod = eventGenerator.generateEvent(method, TRCKR_NAME)
                    addFunction(eventMethod)
                }
            }

            // Factory method
            addFunction("create$trackerName") {
                addParameter(TRCKR_BUILDER_NAME, createLambda<TrckrBuilder>(returnType = UNIT))
                returns(trackerType)
                addCode("return $implName(createTrckr($TRCKR_BUILDER_NAME))")
            }
        }.writeTo(codeGenerator, aggregating = false)
    }

    private fun FileSpec.Builder.addAdapterImports(method: KSFunctionDeclaration) {
        val eventAnnotation = method.getAnnotation<Event>()
        eventAnnotation.getArgumentWithName<ArrayList<KSType>>(
            name = Event.SKIP_ADAPTERS_PROPERTY_NAME,
        ).forEach(::addImport)
    }

    companion object {

        private const val TRCKR_NAME = "trckr"
        private const val TRCKR_BUILDER_NAME = "builder"
        private const val CREATE_TRCKR_IMPORT = "createTrckr"
    }
}
